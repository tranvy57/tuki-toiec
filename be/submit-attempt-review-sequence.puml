@startuml Submit Attempt Review - Adaptive Learning Flow - Tuki TOEIC
!theme plain

actor User
boundary "AttemptController" as Controller
control "AttemptService" as AttemptService
control "UserProgressService" as ProgressService
control "StudyTasksService" as TaskService
control "PlanService" as PlanService
entity "AttemptRepository" as AttemptRepo
entity "AttemptAnswerRepository" as AnswerRepo
entity "UserVocabularyRepository" as UserVocabRepo
entity "VocabularyRepository" as VocabRepo
entity "UserProgressRepository" as ProgressRepo
entity "StudyTaskRepository" as TaskRepo
entity "LessonSkillRepository" as LessonSkillRepo
database "Database" as DB

title Submit Attempt Review - Adaptive Learning & Progress Tracking

== Attempt Submission ==
User -> Controller: POST /attempts/{id}/submit-review
Controller -> AttemptService: submitAttemptReview(attemptId, user)

== Database Transaction Start ==
AttemptService -> DB: Begin Transaction

== Load Attempt Data ==
AttemptService -> AttemptService: loadAttempt(manager, attemptId, user)
AttemptService -> AttemptRepo: findOne(attemptId) with deep relations\n{user, test, parts, groups, questions, answers, questionTags, skill}
AttemptRepo -> DB: SELECT attempt with nested joins
DB --> AttemptRepo: attempt with full question hierarchy
AttemptRepo --> AttemptService: loaded attempt

== Validate User Permission ==
AttemptService -> AttemptService: Check attempt.user.id === user.id
note right: Throws UnauthorizedException if not owner

== Load User Answers ==
AttemptService -> AttemptService: loadAttemptAnswers(manager, attemptId)
AttemptService -> AnswerRepo: find({attempt: attemptId}) with relations
AnswerRepo -> DB: SELECT attempt_answers JOIN answer JOIN question
DB --> AnswerRepo: user's submitted answers
AnswerRepo --> AttemptService: answerMap (questionId -> AttemptAnswer)

== Process Questions & Build Analytics ==
AttemptService -> AttemptService: processQuestions(attempt, answerMap)
note right
  **For each Part > Group > Question:**
  1. Check if user answer is correct
  2. Calculate totalScore, correctCount
  3. Build skillMap: {skillId: {totalScore, totalDiff}}
  4. Extract vocabulary lemmas/phrases
  5. Accumulate skill-based performance data
end note
AttemptService --> AttemptService: {totalScore, correctCount, totalQuestions, skillMap, allKeys}

== Update User Vocabulary Learning ==
AttemptService -> AttemptService: updateUserVocabulary(manager, userId, allKeys, attempt)

=== Vocabulary Dictionary Lookup ===
AttemptService -> VocabRepo: find({lemma: IN(allKeys)})
VocabRepo -> DB: SELECT vocabularies WHERE lemma IN (...)
DB --> VocabRepo: matching vocabulary definitions
VocabRepo --> AttemptService: vocabulary mappings

=== Load Existing User Vocabulary ===
AttemptService -> UserVocabRepo: find({user: userId, vocabulary: IN(vocabIds)})
UserVocabRepo -> DB: SELECT user_vocabularies
DB --> UserVocabRepo: existing vocab progress
UserVocabRepo --> AttemptService: current vocabulary status

=== Calculate Vocabulary Performance ===
AttemptService -> AttemptService: For each vocabulary key:\n1. Find related questions\n2. Count correct/wrong answers\n3. Update status (new/learning/review/mastered)

=== Save Vocabulary Updates ===
AttemptService -> UserVocabRepo: save(updatedUserVocabularies)
UserVocabRepo -> DB: INSERT/UPDATE user_vocabularies
DB --> UserVocabRepo: vocabulary progress updated

== Update Skill Proficiency (Adaptive Learning) ==
AttemptService -> ProgressService: updateUserProgress(manager, userId, skillMap)

=== Load Existing Progress ===
ProgressService -> ProgressRepo: find({user: userId, skill: IN(skillIds)})
ProgressRepo -> DB: SELECT user_progress WHERE user_id AND skill_id IN (...)
DB --> ProgressRepo: current skill proficiencies
ProgressRepo --> ProgressService: existing progress

=== Calculate New Proficiencies ===
ProgressService -> ProgressService: For each skill:\n1. Calculate pLesson = totalScore / totalDiff\n2. Cap between 0.15-0.7\n3. Apply exponential smoothing: (1-α)*old + α*new\n4. α = 0.2 (learning rate)

=== Save Updated Skills ===
ProgressService -> ProgressRepo: save(updatedProgress)
ProgressRepo -> DB: INSERT/UPDATE user_progress SET proficiency
DB --> ProgressRepo: skill progress updated
ProgressRepo --> ProgressService: updated skills
ProgressService --> AttemptService: updatedSkills[]

== Adaptive Study Task Management ==
AttemptService -> TaskService: markSkippableStudyTasks(userId, threshold=0.6)

=== Load User Progress for Task Evaluation ===
TaskService -> ProgressRepo: find({user: userId})
ProgressRepo -> DB: SELECT user_progress WHERE user_id
DB --> ProgressRepo: all user proficiencies
ProgressRepo --> TaskService: proficiency map

=== Load Active Study Tasks ===
TaskService -> TaskRepo: find({isActive: true, plan.user: userId})
TaskRepo -> DB: SELECT study_tasks WHERE active AND user_id
DB --> TaskRepo: active tasks
TaskRepo --> TaskService: tasks to evaluate

=== Evaluate Each Task ===
loop For each study task with lesson
    TaskService -> LessonSkillRepo: find({lesson: taskLessonId})
    LessonSkillRepo -> DB: SELECT lesson_skills WHERE lesson_id
    DB --> LessonSkillRepo: lesson skill requirements
    LessonSkillRepo --> TaskService: lesson skills with weights
    
    TaskService -> TaskService: Calculate weighted average:\navgScore = Σ(proficiency * weight) / Σ(weight)
    
    alt Average Proficiency >= Threshold (0.6)
        TaskService -> TaskService: Mark task as 'skipped'
        TaskService -> TaskRepo: save(task) with status='skipped'
        TaskRepo -> DB: UPDATE study_task SET status='skipped'
        DB --> TaskRepo: task updated
    end
end

TaskService --> AttemptService: skippedTaskIds[]

== Update Learning Plan Status ==
AttemptService -> PlanService: getActivePlanByUserId(manager, userId)
PlanService -> DB: SELECT plan WHERE user_id AND status='active'
DB --> PlanService: active plan
PlanService --> AttemptService: active plan

alt Plan exists
    AttemptService -> PlanService: updatePlan(planId, "in_progress")
    PlanService -> DB: UPDATE plan SET status='in_progress'
    DB --> PlanService: updated plan
end

== Finalize Attempt ==
AttemptService -> AttemptService: updateAttempt(manager, attempt, totalScore)
AttemptService -> AttemptRepo: save(attempt) with status='submitted', finishAt=now()
AttemptRepo -> DB: UPDATE attempt SET status, finishAt, totalScore
DB --> AttemptRepo: attempt finalized

== Commit Transaction ==
AttemptService -> DB: Commit Transaction

== Return Comprehensive Results ==
AttemptService --> Controller: {\nattemptId, score, correctCount, totalQuestions,\nupdatedSkills: [{skillId, proficiency}],\nparts: attempt.parts,\nskippedTasks: [taskId...]\n}
Controller --> User: 200 OK with adaptive learning results

note over User, DB
  **Adaptive Learning Features:**
  • **Skill Proficiency Tracking**: Uses exponential smoothing for skill progress
  • **Vocabulary Mastery**: Tracks word/phrase learning with status progression
  • **Smart Task Skipping**: Automatically skips lessons when proficiency ≥ 60%
  • **Weighted Skill Assessment**: Considers difficulty and skill weights
  • **Learning Plan Progression**: Updates plan status based on performance
  • **Transaction Safety**: All updates in single database transaction
  • **Performance Analytics**: Detailed scoring and progress metrics
end note

@enduml